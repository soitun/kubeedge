// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/beego/beego/v2/client/orm (interfaces: Ormer)

// Package beego is a generated GoMock package.
package beego

import (
	context "context"
	sql "database/sql"
	orm "github.com/beego/beego/v2/client/orm"
	utils "github.com/beego/beego/v2/core/utils"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockOrmer is a mock of Ormer interface
type MockOrmer struct {
	ctrl     *gomock.Controller
	recorder *MockOrmerMockRecorder
}

// MockOrmerMockRecorder is the mock recorder for MockOrmer
type MockOrmerMockRecorder struct {
	mock *MockOrmer
}

// NewMockOrmer creates a new mock instance
func NewMockOrmer(ctrl *gomock.Controller) *MockOrmer {
	mock := &MockOrmer{ctrl: ctrl}
	mock.recorder = &MockOrmerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockOrmer) EXPECT() *MockOrmerMockRecorder {
	return m.recorder
}

// Begin mocks base method
func (m *MockOrmer) Begin() (orm.TxOrmer, error) {
	ret := m.ctrl.Call(m, "Begin")
	ret0, _ := ret[0].(orm.TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin
func (mr *MockOrmerMockRecorder) Begin() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MockOrmer)(nil).Begin))
}

// BeginWithCtx mocks base method
func (m *MockOrmer) BeginWithCtx(arg0 context.Context) (orm.TxOrmer, error) {
	ret := m.ctrl.Call(m, "BeginWithCtx", arg0)
	ret0, _ := ret[0].(orm.TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginWithCtx indicates an expected call of BeginWithCtx
func (mr *MockOrmerMockRecorder) BeginWithCtx(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginWithCtx", reflect.TypeOf((*MockOrmer)(nil).BeginWithCtx), arg0)
}

// BeginWithCtxAndOpts mocks base method
func (m *MockOrmer) BeginWithCtxAndOpts(arg0 context.Context, arg1 *sql.TxOptions) (orm.TxOrmer, error) {
	ret := m.ctrl.Call(m, "BeginWithCtxAndOpts", arg0, arg1)
	ret0, _ := ret[0].(orm.TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginWithCtxAndOpts indicates an expected call of BeginWithCtxAndOpts
func (mr *MockOrmerMockRecorder) BeginWithCtxAndOpts(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginWithCtxAndOpts", reflect.TypeOf((*MockOrmer)(nil).BeginWithCtxAndOpts), arg0, arg1)
}

// BeginWithOpts mocks base method
func (m *MockOrmer) BeginWithOpts(arg0 *sql.TxOptions) (orm.TxOrmer, error) {
	ret := m.ctrl.Call(m, "BeginWithOpts", arg0)
	ret0, _ := ret[0].(orm.TxOrmer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BeginWithOpts indicates an expected call of BeginWithOpts
func (mr *MockOrmerMockRecorder) BeginWithOpts(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BeginWithOpts", reflect.TypeOf((*MockOrmer)(nil).BeginWithOpts), arg0)
}

// DBStats mocks base method
func (m *MockOrmer) DBStats() *sql.DBStats {
	ret := m.ctrl.Call(m, "DBStats")
	ret0, _ := ret[0].(*sql.DBStats)
	return ret0
}

// DBStats indicates an expected call of DBStats
func (mr *MockOrmerMockRecorder) DBStats() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DBStats", reflect.TypeOf((*MockOrmer)(nil).DBStats))
}

// Delete mocks base method
func (m *MockOrmer) Delete(arg0 interface{}, arg1 ...string) (int64, error) {
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Delete", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Delete indicates an expected call of Delete
func (mr *MockOrmerMockRecorder) Delete(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockOrmer)(nil).Delete), varargs...)
}

// DeleteWithCtx mocks base method
func (m *MockOrmer) DeleteWithCtx(arg0 context.Context, arg1 interface{}, arg2 ...string) (int64, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteWithCtx indicates an expected call of DeleteWithCtx
func (mr *MockOrmerMockRecorder) DeleteWithCtx(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteWithCtx", reflect.TypeOf((*MockOrmer)(nil).DeleteWithCtx), varargs...)
}

// DoTx mocks base method
func (m *MockOrmer) DoTx(arg0 func(context.Context, orm.TxOrmer) error) error {
	ret := m.ctrl.Call(m, "DoTx", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTx indicates an expected call of DoTx
func (mr *MockOrmerMockRecorder) DoTx(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTx", reflect.TypeOf((*MockOrmer)(nil).DoTx), arg0)
}

// DoTxWithCtx mocks base method
func (m *MockOrmer) DoTxWithCtx(arg0 context.Context, arg1 func(context.Context, orm.TxOrmer) error) error {
	ret := m.ctrl.Call(m, "DoTxWithCtx", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTxWithCtx indicates an expected call of DoTxWithCtx
func (mr *MockOrmerMockRecorder) DoTxWithCtx(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTxWithCtx", reflect.TypeOf((*MockOrmer)(nil).DoTxWithCtx), arg0, arg1)
}

// DoTxWithCtxAndOpts mocks base method
func (m *MockOrmer) DoTxWithCtxAndOpts(arg0 context.Context, arg1 *sql.TxOptions, arg2 func(context.Context, orm.TxOrmer) error) error {
	ret := m.ctrl.Call(m, "DoTxWithCtxAndOpts", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTxWithCtxAndOpts indicates an expected call of DoTxWithCtxAndOpts
func (mr *MockOrmerMockRecorder) DoTxWithCtxAndOpts(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTxWithCtxAndOpts", reflect.TypeOf((*MockOrmer)(nil).DoTxWithCtxAndOpts), arg0, arg1, arg2)
}

// DoTxWithOpts mocks base method
func (m *MockOrmer) DoTxWithOpts(arg0 *sql.TxOptions, arg1 func(context.Context, orm.TxOrmer) error) error {
	ret := m.ctrl.Call(m, "DoTxWithOpts", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DoTxWithOpts indicates an expected call of DoTxWithOpts
func (mr *MockOrmerMockRecorder) DoTxWithOpts(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DoTxWithOpts", reflect.TypeOf((*MockOrmer)(nil).DoTxWithOpts), arg0, arg1)
}

// Driver mocks base method
func (m *MockOrmer) Driver() orm.Driver {
	ret := m.ctrl.Call(m, "Driver")
	ret0, _ := ret[0].(orm.Driver)
	return ret0
}

// Driver indicates an expected call of Driver
func (mr *MockOrmerMockRecorder) Driver() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Driver", reflect.TypeOf((*MockOrmer)(nil).Driver))
}

// Insert mocks base method
func (m *MockOrmer) Insert(arg0 interface{}) (int64, error) {
	ret := m.ctrl.Call(m, "Insert", arg0)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert
func (mr *MockOrmerMockRecorder) Insert(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockOrmer)(nil).Insert), arg0)
}

// InsertMulti mocks base method
func (m *MockOrmer) InsertMulti(arg0 int, arg1 interface{}) (int64, error) {
	ret := m.ctrl.Call(m, "InsertMulti", arg0, arg1)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMulti indicates an expected call of InsertMulti
func (mr *MockOrmerMockRecorder) InsertMulti(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMulti", reflect.TypeOf((*MockOrmer)(nil).InsertMulti), arg0, arg1)
}

// InsertMultiWithCtx mocks base method
func (m *MockOrmer) InsertMultiWithCtx(arg0 context.Context, arg1 int, arg2 interface{}) (int64, error) {
	ret := m.ctrl.Call(m, "InsertMultiWithCtx", arg0, arg1, arg2)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertMultiWithCtx indicates an expected call of InsertMultiWithCtx
func (mr *MockOrmerMockRecorder) InsertMultiWithCtx(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertMultiWithCtx", reflect.TypeOf((*MockOrmer)(nil).InsertMultiWithCtx), arg0, arg1, arg2)
}

// InsertOrUpdate mocks base method
func (m *MockOrmer) InsertOrUpdate(arg0 interface{}, arg1 ...string) (int64, error) {
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdate", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdate indicates an expected call of InsertOrUpdate
func (mr *MockOrmerMockRecorder) InsertOrUpdate(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdate", reflect.TypeOf((*MockOrmer)(nil).InsertOrUpdate), varargs...)
}

// InsertOrUpdateWithCtx mocks base method
func (m *MockOrmer) InsertOrUpdateWithCtx(arg0 context.Context, arg1 interface{}, arg2 ...string) (int64, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "InsertOrUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertOrUpdateWithCtx indicates an expected call of InsertOrUpdateWithCtx
func (mr *MockOrmerMockRecorder) InsertOrUpdateWithCtx(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertOrUpdateWithCtx", reflect.TypeOf((*MockOrmer)(nil).InsertOrUpdateWithCtx), varargs...)
}

// InsertWithCtx mocks base method
func (m *MockOrmer) InsertWithCtx(arg0 context.Context, arg1 interface{}) (int64, error) {
	ret := m.ctrl.Call(m, "InsertWithCtx", arg0, arg1)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// InsertWithCtx indicates an expected call of InsertWithCtx
func (mr *MockOrmerMockRecorder) InsertWithCtx(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InsertWithCtx", reflect.TypeOf((*MockOrmer)(nil).InsertWithCtx), arg0, arg1)
}

// LoadRelated mocks base method
func (m *MockOrmer) LoadRelated(arg0 interface{}, arg1 string, arg2 ...utils.KV) (int64, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelated", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelated indicates an expected call of LoadRelated
func (mr *MockOrmerMockRecorder) LoadRelated(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelated", reflect.TypeOf((*MockOrmer)(nil).LoadRelated), varargs...)
}

// LoadRelatedWithCtx mocks base method
func (m *MockOrmer) LoadRelatedWithCtx(arg0 context.Context, arg1 interface{}, arg2 string, arg3 ...utils.KV) (int64, error) {
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "LoadRelatedWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// LoadRelatedWithCtx indicates an expected call of LoadRelatedWithCtx
func (mr *MockOrmerMockRecorder) LoadRelatedWithCtx(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadRelatedWithCtx", reflect.TypeOf((*MockOrmer)(nil).LoadRelatedWithCtx), varargs...)
}

// QueryM2M mocks base method
func (m *MockOrmer) QueryM2M(arg0 interface{}, arg1 string) orm.QueryM2Mer {
	ret := m.ctrl.Call(m, "QueryM2M", arg0, arg1)
	ret0, _ := ret[0].(orm.QueryM2Mer)
	return ret0
}

// QueryM2M indicates an expected call of QueryM2M
func (mr *MockOrmerMockRecorder) QueryM2M(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2M", reflect.TypeOf((*MockOrmer)(nil).QueryM2M), arg0, arg1)
}

// QueryM2MWithCtx mocks base method
func (m *MockOrmer) QueryM2MWithCtx(arg0 context.Context, arg1 interface{}, arg2 string) orm.QueryM2Mer {
	ret := m.ctrl.Call(m, "QueryM2MWithCtx", arg0, arg1, arg2)
	ret0, _ := ret[0].(orm.QueryM2Mer)
	return ret0
}

// QueryM2MWithCtx indicates an expected call of QueryM2MWithCtx
func (mr *MockOrmerMockRecorder) QueryM2MWithCtx(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryM2MWithCtx", reflect.TypeOf((*MockOrmer)(nil).QueryM2MWithCtx), arg0, arg1, arg2)
}

// QueryTable mocks base method
func (m *MockOrmer) QueryTable(arg0 interface{}) orm.QuerySeter {
	ret := m.ctrl.Call(m, "QueryTable", arg0)
	ret0, _ := ret[0].(orm.QuerySeter)
	return ret0
}

// QueryTable indicates an expected call of QueryTable
func (mr *MockOrmerMockRecorder) QueryTable(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTable", reflect.TypeOf((*MockOrmer)(nil).QueryTable), arg0)
}

// QueryTableWithCtx mocks base method
func (m *MockOrmer) QueryTableWithCtx(arg0 context.Context, arg1 interface{}) orm.QuerySeter {
	ret := m.ctrl.Call(m, "QueryTableWithCtx", arg0, arg1)
	ret0, _ := ret[0].(orm.QuerySeter)
	return ret0
}

// QueryTableWithCtx indicates an expected call of QueryTableWithCtx
func (mr *MockOrmerMockRecorder) QueryTableWithCtx(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueryTableWithCtx", reflect.TypeOf((*MockOrmer)(nil).QueryTableWithCtx), arg0, arg1)
}

// Raw mocks base method
func (m *MockOrmer) Raw(arg0 string, arg1 ...interface{}) orm.RawSeter {
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Raw", varargs...)
	ret0, _ := ret[0].(orm.RawSeter)
	return ret0
}

// Raw indicates an expected call of Raw
func (mr *MockOrmerMockRecorder) Raw(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Raw", reflect.TypeOf((*MockOrmer)(nil).Raw), varargs...)
}

// RawWithCtx mocks base method
func (m *MockOrmer) RawWithCtx(arg0 context.Context, arg1 string, arg2 ...interface{}) orm.RawSeter {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RawWithCtx", varargs...)
	ret0, _ := ret[0].(orm.RawSeter)
	return ret0
}

// RawWithCtx indicates an expected call of RawWithCtx
func (mr *MockOrmerMockRecorder) RawWithCtx(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RawWithCtx", reflect.TypeOf((*MockOrmer)(nil).RawWithCtx), varargs...)
}

// Read mocks base method
func (m *MockOrmer) Read(arg0 interface{}, arg1 ...string) error {
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Read", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Read indicates an expected call of Read
func (mr *MockOrmerMockRecorder) Read(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Read", reflect.TypeOf((*MockOrmer)(nil).Read), varargs...)
}

// ReadForUpdate mocks base method
func (m *MockOrmer) ReadForUpdate(arg0 interface{}, arg1 ...string) error {
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdate", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdate indicates an expected call of ReadForUpdate
func (mr *MockOrmerMockRecorder) ReadForUpdate(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdate", reflect.TypeOf((*MockOrmer)(nil).ReadForUpdate), varargs...)
}

// ReadForUpdateWithCtx mocks base method
func (m *MockOrmer) ReadForUpdateWithCtx(arg0 context.Context, arg1 interface{}, arg2 ...string) error {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadForUpdateWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadForUpdateWithCtx indicates an expected call of ReadForUpdateWithCtx
func (mr *MockOrmerMockRecorder) ReadForUpdateWithCtx(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadForUpdateWithCtx", reflect.TypeOf((*MockOrmer)(nil).ReadForUpdateWithCtx), varargs...)
}

// ReadOrCreate mocks base method
func (m *MockOrmer) ReadOrCreate(arg0 interface{}, arg1 string, arg2 ...string) (bool, int64, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreate", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreate indicates an expected call of ReadOrCreate
func (mr *MockOrmerMockRecorder) ReadOrCreate(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreate", reflect.TypeOf((*MockOrmer)(nil).ReadOrCreate), varargs...)
}

// ReadOrCreateWithCtx mocks base method
func (m *MockOrmer) ReadOrCreateWithCtx(arg0 context.Context, arg1 interface{}, arg2 string, arg3 ...string) (bool, int64, error) {
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadOrCreateWithCtx", varargs...)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int64)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ReadOrCreateWithCtx indicates an expected call of ReadOrCreateWithCtx
func (mr *MockOrmerMockRecorder) ReadOrCreateWithCtx(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrCreateWithCtx", reflect.TypeOf((*MockOrmer)(nil).ReadOrCreateWithCtx), varargs...)
}

// ReadWithCtx mocks base method
func (m *MockOrmer) ReadWithCtx(arg0 context.Context, arg1 interface{}, arg2 ...string) error {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ReadWithCtx", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReadWithCtx indicates an expected call of ReadWithCtx
func (mr *MockOrmerMockRecorder) ReadWithCtx(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadWithCtx", reflect.TypeOf((*MockOrmer)(nil).ReadWithCtx), varargs...)
}

// Update mocks base method
func (m *MockOrmer) Update(arg0 interface{}, arg1 ...string) (int64, error) {
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Update", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Update indicates an expected call of Update
func (mr *MockOrmerMockRecorder) Update(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockOrmer)(nil).Update), varargs...)
}

// UpdateWithCtx mocks base method
func (m *MockOrmer) UpdateWithCtx(arg0 context.Context, arg1 interface{}, arg2 ...string) (int64, error) {
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateWithCtx", varargs...)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// UpdateWithCtx indicates an expected call of UpdateWithCtx
func (mr *MockOrmerMockRecorder) UpdateWithCtx(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateWithCtx", reflect.TypeOf((*MockOrmer)(nil).UpdateWithCtx), varargs...)
}
